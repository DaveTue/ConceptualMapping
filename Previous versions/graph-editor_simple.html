<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Text â†’ Graph Demo</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
    }

    /* Left: text input */
    #editor {
      width: 40%;
      padding: 10px;
      box-sizing: border-box;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #editor textarea {
      flex: 1;
      width: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
    }

    #header {
      font-size: 14px;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 13px;
    }

    #controls button {
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
    }

    #fileNameInput {
      width: 140px;
      padding: 3px 5px;
      font-size: 13px;
    }

    /* Right: canvas */
    #viewer {
      flex: 1;
      position: relative;
    }

    #graphCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #f9f9f9;
      cursor: grab;
    }

    #graphCanvas.dragging {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div id="editor">
    <!-- <div id="header">
      Type one edge per line, e.g.:<br>
      <code>Beer -> Yeast : is fermented by</code><br>
      <code>Beer causes Hangover : after a party</code><br>
      or<br>
      <code>Beer causes Hangover : after a party</code> (space-RELATION-space)
    </div> -->

      <div id="header">
        Type one edge per line, e.g.:<br>
        <code>Building -> HotWater : uses</code><br>
        <code>Non-Residential -> Building : typeOf</code><br>
        <code>Fuel -> Heating : sourceType</code><br>
        Or more specific relationships, e.g.:<br>
        <code>Building property inhabitants : contains</code> (concept1-relationshipType|Relationship-concept2)<br>
        <code>Heating computes powerPerHour : consumes</code> (concept1-relationshipType|Relationship-concept2)
      </div>


    <!-- Save / Load controls -->
    <div id="controls">
      <button id="saveBtn">Save</button>
      <input
        type="text"
        id="fileNameInput"
        placeholder="graph.txt"
        aria-label="File name"
      />
      <input type="file" id="fileInput" accept=".txt,.text" />
      <span>(upload a text file to load it)</span>
    </div>

    <textarea id="graphText" spellcheck="false"></textarea>
  </div>

  <div id="viewer">
    <canvas id="graphCanvas"></canvas>
  </div>

  <script>
    const textarea = document.getElementById('graphText');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');

    const saveBtn = document.getElementById('saveBtn');
    const fileInput = document.getElementById('fileInput');
    const fileNameInput = document.getElementById('fileNameInput');

    // Zoom / pan state
    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    const minScale = 0.3;
    const maxScale = 3.0;

    let isPanning = false;
    let startPanX = 0;
    let startPanY = 0;
    let startOffsetX = 0;
    let startOffsetY = 0;

    // Current graph data (so we can re-draw without re-parsing on zoom/pan)
    let currentNodes = [];
    let currentEdges = [];

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      drawGraphFromText(textarea.value);
    }

    window.addEventListener('resize', resizeCanvas);

    textarea.value =
// `Beer -> Yeast : is fermented by
// Beer causes Hangover : after a party
// Yeast affects Flavor : depending on strain`;
    `Building -> HotWater : uses
Non-Residential -> Building : typeOf
Fuel -> Heating : sourceType
Building property inhabitants : contains
Heating computes powerPerHour : consumes`;

    textarea.addEventListener('input', () => {
      // Reset zoom/pan on new text (optional)
      scale = 1.0;
      offsetX = 0;
      offsetY = 0;
      drawGraphFromText(textarea.value);
    });

    // ---------- Save text to file ----------

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' }); // [web:69]
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    saveBtn.addEventListener('click', () => {
      const content = textarea.value;
      let name = fileNameInput.value.trim();
      if (!name) {
        name = 'graph.txt';
      } else if (!name.includes('.')) {
        name = name + '.txt';
      }
      downloadTextFile(name, content);
    });

    // ---------- Load text file into textarea ----------

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const contents = e.target.result;
        textarea.value = contents;
        // reset view when loading new file
        scale = 1.0;
        offsetX = 0;
        offsetY = 0;
        drawGraphFromText(textarea.value);
        fileNameInput.value = file.name;
      };
      reader.readAsText(file);
      fileInput.value = '';
    });

    // ---------- Parsing ----------

    function parseGraph(text) {
      const nodesMap = new Map(); // name -> { name, x, y, vx, vy }
      const edges = [];

      const lines = text.split('\n');
      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        const [leftPart, edgeTextPart] = line.split(':').map(s => s && s.trim());
        const edgeText = edgeTextPart || '';

        let src, rel, tgt;

        if (leftPart.includes('->')) {
          const [leftSrc, leftRest] = leftPart.split('->');
          src = leftSrc.trim();
          const parts = leftRest.trim().split(/\s+/);
          tgt = parts.shift();
          rel = parts.join(' ').trim() || '';
        } else {
          const tokens = leftPart.split(/\s+/);
          if (tokens.length < 3) continue;
          src = tokens[0];
          tgt = tokens[tokens.length - 1];
          rel = tokens.slice(1, tokens.length - 1).join(' ');
        }

        if (!src || !tgt) continue;

        if (!nodesMap.has(src)) nodesMap.set(src, { name: src });
        if (!nodesMap.has(tgt)) nodesMap.set(tgt, { name: tgt });

        edges.push({
          source: src,
          target: tgt,
          relation: rel,
          text: edgeText
        });
      }

      return { nodes: Array.from(nodesMap.values()), edges };
    }

    // ---------- Simple force-directed layout ----------

    function layoutNodesForce(nodes, edges, width, height) {
      if (!nodes.length) return;

      const centerX = width / 2;
      const centerY = height / 2;

      const n = nodes.length;
      const initRadius = Math.min(width, height) * 0.3;
      nodes.forEach((node, i) => {
        if (node.x == null || node.y == null) {
          const angle = (2 * Math.PI * i) / n;
          node.x = centerX + initRadius * Math.cos(angle);
          node.y = centerY + initRadius * Math.sin(angle);
        }
        node.vx = node.vx || 0;
        node.vy = node.vy || 0;
      });

      const nodeIndex = new Map(nodes.map((n, i) => [n.name, i]));

      const iterations = 80;
      const repulsion = 4000;
      const springLength = 120;
      const springK = 0.01;
      const centerPull = 0.005;
      const damping = 0.85;

      for (let iter = 0; iter < iterations; iter++) {
        nodes.forEach(node => {
          node.fx = 0;
          node.fy = 0;
        });

        // Node-node repulsion
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            let dist2 = dx * dx + dy * dy;
            if (dist2 === 0) {
              dx = (Math.random() - 0.5) * 0.1;
              dy = (Math.random() - 0.5) * 0.1;
              dist2 = dx * dx + dy * dy;
            }
            const dist = Math.sqrt(dist2);
            const force = repulsion / dist2;
            const fx = (force * dx) / dist;
            const fy = (force * dy) / dist;

            a.fx -= fx;
            a.fy -= fy;
            b.fx += fx;
            b.fy += fy;
          }
        }

        // Edge springs
        edges.forEach(e => {
          const a = nodes[nodeIndex.get(e.source)];
          const b = nodes[nodeIndex.get(e.target)];
          if (!a || !b) return;

          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
          const delta = dist - springLength;
          const force = springK * delta;
          const fx = (force * dx) / dist;
          const fy = (force * dy) / dist;

          a.fx += fx;
          a.fy += fy;
          b.fx -= fx;
          b.fy -= fy;
        });

        // Centering force
        nodes.forEach(node => {
          const dx = centerX - node.x;
          const dy = centerY - node.y;
          node.fx += centerPull * dx;
          node.fy += centerPull * dy;
        });

        // Integrate
        nodes.forEach(node => {
          node.vx = (node.vx + node.fx) * damping;
          node.vy = (node.vy + node.fy) * damping;
          node.x += node.vx;
          node.y += node.vy;
        });
      }
    }

    // ---------- Drawing with zoom/pan ----------

    function drawGraphFromText(text) {
      const { nodes, edges } = parseGraph(text);
      currentNodes = nodes;
      currentEdges = edges;

      const w = canvas.width;
      const h = canvas.height;

      if (!nodes.length) {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, w, h);
        return;
      }

      layoutNodesForce(nodes, edges, w, h);
      drawGraph();
    }

    function drawGraph() {
      const nodes = currentNodes;
      const edges = currentEdges;
      const w = canvas.width;
      const h = canvas.height;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);

      // Apply zoom and pan
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale); // [web:96][web:99][web:102]

      if (!nodes.length) return;

      const nodeIndex = new Map(nodes.map((n, i) => [n.name, i]));

      // Draw edges
      ctx.strokeStyle = '#555';
      ctx.fillStyle = '#000';
      ctx.lineWidth = 1.5 / scale; // keep thickness roughly stable
      ctx.font = `${12 / scale}px sans-serif`;

      for (const e of edges) {
        const s = nodes[nodeIndex.get(e.source)];
        const t = nodes[nodeIndex.get(e.target)];
        if (!s || !t) continue;

        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();

        const label = [e.relation, e.text].filter(Boolean).join(' | ');
        if (label) {
          const mx = (s.x + t.x) / 2;
          const my = (s.y + t.y) / 2;
          ctx.save();
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          const padding = 4 / scale;
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(mx - textWidth / 2 - padding, my - 10 / scale, textWidth + 2 * padding, 16 / scale);
          ctx.fillStyle = '#333';
          ctx.fillText(label, mx - textWidth / 2, my + 2 / scale);
          ctx.restore();
        }
      }

      // Draw nodes with auto-sized boxes
      for (const node of nodes) {
        const label = node.name;

        ctx.font = `${12 / scale}px sans-serif`;
        const paddingX = 10 / scale;
        const paddingY = 6 / scale;

        const textWidth = ctx.measureText(label).width;
        const textHeight = 12 / scale;

        const boxWidth = textWidth + 2 * paddingX;
        const boxHeight = textHeight + 2 * paddingY;

        const x = node.x - boxWidth / 2;
        const y = node.y - boxHeight / 2;

        ctx.beginPath();
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#0074D9';
        ctx.lineWidth = 2 / scale;
        ctx.rect(x, y, boxWidth, boxHeight);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#000000';
        const textX = node.x - textWidth / 2;
        const textY = node.y + textHeight / 2 - 2 / scale;
        ctx.fillText(label, textX, textY);
      }
    }

    // ---------- Mouse wheel zoom ----------

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      // Convert screen coords to graph coords before zoom
      const xBeforeZoom = (mouseX - offsetX) / scale;
      const yBeforeZoom = (mouseY - offsetY) / scale;

      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9; // wheel up: zoom in
      const newScale = Math.min(maxScale, Math.max(minScale, scale * zoomFactor));

      // Adjust offset so the point under the cursor stays in place
      scale = newScale;
      offsetX = mouseX - xBeforeZoom * scale;
      offsetY = mouseY - yBeforeZoom * scale;

      drawGraph();
    }, { passive: false }); // [web:90][web:95][web:96]

    // ---------- Mouse drag pan ----------

    canvas.addEventListener('mousedown', (event) => {
      isPanning = true;
      canvas.classList.add('dragging');
      startPanX = event.clientX;
      startPanY = event.clientY;
      startOffsetX = offsetX;
      startOffsetY = offsetY;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isPanning) return;
      const dx = event.clientX - startPanX;
      const dy = event.clientY - startPanY;
      offsetX = startOffsetX + dx;
      offsetY = startOffsetY + dy;
      drawGraph();
    });

    window.addEventListener('mouseup', () => {
      isPanning = false;
      canvas.classList.remove('dragging');
    });

    // Initial sizing and draw
    resizeCanvas();
  </script>
</body>
</html>
