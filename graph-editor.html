<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Text â†’ Graph Demo</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
    }

    /* Left: text input */
    #editor {
      width: 40%;
      padding: 10px;
      box-sizing: border-box;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #editor textarea {
      flex: 1;
      width: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
    }

    #header {
      font-size: 14px;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 13px;
    }

    #controls button {
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
    }

    #fileNameInput {
      width: 140px;
      padding: 3px 5px;
      font-size: 13px;
    }

    /* Right: canvas */
    #viewer {
      flex: 1;
      position: relative;
    }

    #graphCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #f9f9f9;
    }
  </style>
</head>
<body>
  <div id="editor">
    <div id="header">
      Type one edge per line, e.g.:<br>
      <code>Beer -> Yeast : is fermented by</code><br>
      <code>Beer causes Hangover : after a party</code><br>
      or<br>
      <code>Beer causes Hangover : after a party</code> (space-RELATION-space)
    </div>

    <!-- Save / Load controls -->
    <div id="controls">
      <button id="saveBtn">Save</button>
      <input
        type="text"
        id="fileNameInput"
        placeholder="graph.txt"
        aria-label="File name"
      />
      <input type="file" id="fileInput" accept=".txt,.text" />
      <span>(upload a text file to load it)</span>
    </div>

    <textarea id="graphText" spellcheck="false"></textarea>
  </div>

  <div id="viewer">
    <canvas id="graphCanvas"></canvas>
  </div>

  <script>
    const textarea = document.getElementById('graphText');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');

    const saveBtn = document.getElementById('saveBtn');
    const fileInput = document.getElementById('fileInput');
    const fileNameInput = document.getElementById('fileNameInput');

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      drawGraphFromText(textarea.value);
    }

    window.addEventListener('resize', resizeCanvas);

    textarea.value =
`Beer -> Yeast : is fermented by
Beer causes Hangover : after a party
Yeast affects Flavor : depending on strain`;

    textarea.addEventListener('input', () => {
      drawGraphFromText(textarea.value);
    });

    // ---------- Save text to file ----------

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' }); // [web:69]
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    saveBtn.addEventListener('click', () => {
      const content = textarea.value;
      let name = fileNameInput.value.trim();
      if (!name) {
        name = 'graph.txt';
      } else if (!name.includes('.')) {
        name = name + '.txt';
      }
      downloadTextFile(name, content); // [web:60][web:69]
    });

    // ---------- Load text file into textarea ----------

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader(); // [web:68][web:71]
      reader.onload = (e) => {
        const contents = e.target.result;
        textarea.value = contents;
        drawGraphFromText(textarea.value);
        fileNameInput.value = file.name;
      };
      reader.readAsText(file);
      fileInput.value = '';
    });

    // ---------- Parsing ----------

    function parseGraph(text) {
      const nodes = new Map(); // name -> { name, x, y, vx, vy }
      const edges = [];

      const lines = text.split('\n');
      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        const [leftPart, edgeTextPart] = line.split(':').map(s => s && s.trim());
        const edgeText = edgeTextPart || '';

        let src, rel, tgt;

        if (leftPart.includes('->')) {
          const [leftSrc, leftRest] = leftPart.split('->');
          src = leftSrc.trim();
          const parts = leftRest.trim().split(/\s+/);
          tgt = parts.shift();
          rel = parts.join(' ').trim() || '';
        } else {
          const tokens = leftPart.split(/\s+/);
          if (tokens.length < 3) continue;
          src = tokens[0];
          tgt = tokens[tokens.length - 1];
          rel = tokens.slice(1, tokens.length - 1).join(' ');
        }

        if (!src || !tgt) continue;

        if (!nodes.has(src)) nodes.set(src, { name: src });
        if (!nodes.has(tgt)) nodes.set(tgt, { name: tgt });

        edges.push({
          source: src,
          target: tgt,
          relation: rel,
          text: edgeText
        });
      }

      return { nodes: Array.from(nodes.values()), edges };
    }

    // ---------- Simple force-directed layout ----------

    function layoutNodesForce(nodes, edges, width, height) {
      if (!nodes.length) return;

      const centerX = width / 2;
      const centerY = height / 2;

      // Initialize positions (if missing) on a circle
      const n = nodes.length;
      const initRadius = Math.min(width, height) * 0.3;
      nodes.forEach((node, i) => {
        if (node.x == null || node.y == null) {
          const angle = (2 * Math.PI * i) / n;
          node.x = centerX + initRadius * Math.cos(angle);
          node.y = centerY + initRadius * Math.sin(angle);
        }
        node.vx = node.vx || 0;
        node.vy = node.vy || 0;
      });

      const nodeIndex = new Map(nodes.map((n, i) => [n.name, i]));

      const iterations = 80;           // small but enough for static layout
      const repulsion = 4000;          // node-node repulsion strength
      const springLength = 120;        // ideal edge length
      const springK = 0.01;            // edge spring strength
      const centerPull = 0.005;        // how strongly nodes are pulled to center
      const damping = 0.85;            // velocity damping

      for (let iter = 0; iter < iterations; iter++) {
        // Reset forces
        nodes.forEach(node => {
          node.fx = 0;
          node.fy = 0;
        });

        // Node-node repulsion
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            let dist2 = dx * dx + dy * dy;
            if (dist2 === 0) {
              dx = (Math.random() - 0.5) * 0.1;
              dy = (Math.random() - 0.5) * 0.1;
              dist2 = dx * dx + dy * dy;
            }
            const dist = Math.sqrt(dist2);
            const force = repulsion / dist2;
            const fx = (force * dx) / dist;
            const fy = (force * dy) / dist;

            a.fx -= fx;
            a.fy -= fy;
            b.fx += fx;
            b.fy += fy;
          }
        }

        // Edge springs
        edges.forEach(e => {
          const a = nodes[nodeIndex.get(e.source)];
          const b = nodes[nodeIndex.get(e.target)];
          if (!a || !b) return;

          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
          const delta = dist - springLength;
          const force = springK * delta;
          const fx = (force * dx) / dist;
          const fy = (force * dy) / dist;

          a.fx += fx;
          a.fy += fy;
          b.fx -= fx;
          b.fy -= fy;
        });

        // Centering force
        nodes.forEach(node => {
          const dx = centerX - node.x;
          const dy = centerY - node.y;
          node.fx += centerPull * dx;
          node.fy += centerPull * dy;
        });

        // Integrate velocities and positions
        nodes.forEach(node => {
          node.vx = (node.vx + node.fx) * damping;
          node.vy = (node.vy + node.fy) * damping;

          node.x += node.vx;
          node.y += node.vy;
        });
      }
    }

    // ---------- Drawing (auto-sized boxes) ----------

    function drawGraphFromText(text) {
      const { nodes, edges } = parseGraph(text);
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);
      if (!nodes.length) return;

      // Use the force layout instead of simple circle
      layoutNodesForce(nodes, edges, w, h);

      const nodeIndex = new Map(nodes.map((n, i) => [n.name, i]));

      // Draw edges
      ctx.strokeStyle = '#555';
      ctx.fillStyle = '#000';
      ctx.lineWidth = 1.5;
      ctx.font = '12px sans-serif';

      for (const e of edges) {
        const s = nodes[nodeIndex.get(e.source)];
        const t = nodes[nodeIndex.get(e.target)];
        if (!s || !t) continue;

        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();

        const label = [e.relation, e.text].filter(Boolean).join(' | ');
        if (label) {
          const mx = (s.x + t.x) / 2;
          const my = (s.y + t.y) / 2;
          ctx.save();
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          const padding = 4;
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(mx - textWidth / 2 - padding, my - 10, textWidth + 2 * padding, 16);
          ctx.fillStyle = '#333';
          ctx.fillText(label, mx - textWidth / 2, my + 2);
          ctx.restore();
        }
      }

      // Draw nodes with auto-sized boxes
      for (const node of nodes) {
        const label = node.name;
        ctx.font = '12px sans-serif';

        const paddingX = 10;
        const paddingY = 6;

        const textWidth = ctx.measureText(label).width;
        const textHeight = 12;

        const boxWidth = textWidth + 2 * paddingX;
        const boxHeight = textHeight + 2 * paddingY;

        const x = node.x - boxWidth / 2;
        const y = node.y - boxHeight / 2;

        ctx.beginPath();
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#0074D9';
        ctx.lineWidth = 2;
        ctx.rect(x, y, boxWidth, boxHeight);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#000000';
        const textX = node.x - textWidth / 2;
        const textY = node.y + textHeight / 2 - 2;
        ctx.fillText(label, textX, textY);
      }
    }

    // Initial sizing and draw
    resizeCanvas();
  </script>
</body>
</html>
