<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Text â†’ Graph Demo</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      height: 100vh;
      display: flex;
    }

    /* Left: text input */
    #editor {
      width: 40%;
      padding: 10px;
      box-sizing: border-box;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #editor textarea {
      flex: 1;
      width: 100%;
      resize: none;
      font-family: monospace;
      font-size: 14px;
    }

    #header {
      font-size: 14px;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 13px;
    }

    #controls button {
      padding: 4px 8px;
      font-size: 13px;
      cursor: pointer;
    }

    #fileNameInput {
      width: 140px;
      padding: 3px 5px;
      font-size: 13px;
    }

    /* Right: canvas */
    #viewer {
      flex: 1;
      position: relative;
    }

    #graphCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #f9f9f9;
      cursor: grab;
    }

    #graphCanvas.dragging {
      cursor: grabbing;
    }
  </style>
</head>
<body>
  <div id="editor">
    <div id="header">
      Type one edge per line, e.g.:<br>
      <code>Building -> HotWater : uses</code><br>
      <code>Non-Residential -> Building : typeOf</code><br>
      <code>Fuel -> Heating : sourceType</code><br>
      Or more specific relationships, e.g.:<br>
      <code>Building property surface : has</code> (concept1-relationshipType|Relationship-concept2)<br>
      <code>Heating computes powerPerHour : consumes</code> (concept1-relationshipType|Relationship-concept2)<br>
      Add concept definitions with:<br>
      <code>def Building = A human-made structure providing shelter or space.</code>
    </div>

    <!-- Save / Load controls -->
    <div id="controls">
      <button id="saveBtn">Save</button>
      <input
        type="text"
        id="fileNameInput"
        placeholder="graph.txt"
        aria-label="File name"
      />
      <input type="file" id="fileInput" accept=".txt,.text" />
      <span>(upload a text file to load it)</span>
    </div>

    <textarea id="graphText" spellcheck="false"></textarea>
  </div>

  <div id="viewer">
    <canvas id="graphCanvas"></canvas>
  </div>

  <script>
    const textarea = document.getElementById('graphText');
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');

    const saveBtn = document.getElementById('saveBtn');
    const fileInput = document.getElementById('fileInput');
    const fileNameInput = document.getElementById('fileNameInput');

    // Zoom / pan state
    let scale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    const minScale = 0.3;
    const maxScale = 3.0;

    let isPanning = false;
    let startPanX = 0;
    let startPanY = 0;
    let startOffsetX = 0;
    let startOffsetY = 0;

    // Current graph data
    let currentNodes = [];
    let currentEdges = [];
    let currentDefinitions = {}; // conceptName -> definition text (not yet displayed)

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      drawGraphFromText(textarea.value);
    }

    window.addEventListener('resize', resizeCanvas);

    textarea.value =
`Building -> HotWater : uses
Non-Residential -> Building : typeOf
Fuel -> Heating : sourceType
Building property surface : has
Heating computes powerPerHour : consumes
def Building = A human-made structure providing shelter or space.
def Heating = Process that raises indoor temperature.`;

    textarea.addEventListener('input', () => {
      scale = 1.0;
      offsetX = 0;
      offsetY = 0;
      drawGraphFromText(textarea.value);
    });

    // ---------- Save text to file ----------

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    saveBtn.addEventListener('click', () => {
      const content = textarea.value;
      let name = fileNameInput.value.trim();
      if (!name) {
        name = 'graph.txt';
      } else if (!name.includes('.')) {
        name = name + '.txt';
      }
      downloadTextFile(name, content);
    });

    // ---------- Load text file into textarea ----------

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const contents = e.target.result;
        textarea.value = contents;
        scale = 1.0;
        offsetX = 0;
        offsetY = 0;
        drawGraphFromText(textarea.value);
        fileNameInput.value = file.name;
      };
      reader.readAsText(file);
      fileInput.value = '';
    });

    // ---------- Parsing with main / type / non-main concepts + definitions ----------

    function parseGraph(text) {
      const nodesMap = new Map(); // name -> { name, x, y, vx, vy, isMain, isTypeConcept, hasDefinition }
      const edges = [];
      const definitions = {}; // name -> definition string

      const lines = text.split('\n');
      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        // 1) Definition lines: def Name = description
        if (line.startsWith('def ')) {
          const defBody = line.slice(4).trim(); // remove "def "
          const eqIndex = defBody.indexOf('=');
          if (eqIndex !== -1) {
            const namePart = defBody.slice(0, eqIndex).trim();
            const defText = defBody.slice(eqIndex + 1).trim();
            if (namePart) {
              definitions[namePart] = defText;
              if (!nodesMap.has(namePart)) {
                nodesMap.set(namePart, { name: namePart });
              }
              const node = nodesMap.get(namePart);
              node.hasDefinition = true;
            }
          }
          continue; // skip to next line (definition lines do not create edges)
        }

        // 2) Edge / concept lines
        const [leftPart, edgeTextPart] = line.split(':').map(s => s && s.trim());
        const edgeText = edgeTextPart || '';

        let src, rel, tgt;

        if (leftPart.includes('->')) {
          const [leftSrc, leftRest] = leftPart.split('->');
          src = leftSrc.trim();
          const parts = leftRest.trim().split(/\s+/);
          tgt = parts.shift();
          rel = parts.join(' ').trim() || '';

          const tokens = leftPart.split(/\s+/);
          ensureNodesAndMark(tokens, src, tgt, rel, nodesMap);
        } else {
          const tokens = leftPart.split(/\s+/);
          if (tokens.length < 3) continue;
          src = tokens[0];
          tgt = tokens[tokens.length - 1];
          rel = tokens.slice(1, tokens.length - 1).join(' ');

          ensureNodesAndMark(tokens, src, tgt, rel, nodesMap);
        }

        if (!src || !tgt) continue;

        edges.push({
          source: src,
          target: tgt,
          relation: rel,
          text: edgeText
        });
      }

      // Mark definitions on nodes that may have been created after def lines
      for (const [name, defText] of Object.entries(definitions)) {
        if (!nodesMap.has(name)) {
          nodesMap.set(name, { name });
        }
        const node = nodesMap.get(name);
        node.hasDefinition = true;
      }

      currentDefinitions = definitions;
      return { nodes: Array.from(nodesMap.values()), edges };
    }

    // Helper to ensure nodes exist and mark main / non-main / typeConcept
    function ensureNodesAndMark(tokens, srcName, tgtName, relationText, nodesMap) {
      if (!nodesMap.has(srcName)) nodesMap.set(srcName, { name: srcName });
      if (!nodesMap.has(tgtName)) nodesMap.set(tgtName, { name: tgtName });

      function ensureNode(name) {
        const node = nodesMap.get(name);
        if (node.isMain === undefined) {
          node.isMain = true; // default
        }
        if (node.isTypeConcept === undefined) {
          node.isTypeConcept = false;
        }
        if (node.hasDefinition === undefined) {
          node.hasDefinition = false;
        }
        return node;
      }

      const relationshipMarkers = ["property", "computes"];

      // Source concept: main
      ensureNode(srcName).isMain = true;

      const lowerTokens = tokens.map(t => t.toLowerCase());
      const targetNode = ensureNode(tgtName);

      if (lowerTokens.length >= 3) {
        const preLast = lowerTokens[lowerTokens.length - 2];
        const isRelType = relationshipMarkers.includes(preLast);
        if (isRelType) {
          targetNode.isMain = false; // attribute-like concept
        } else {
          if (targetNode.isMain !== false) {
            targetNode.isMain = true;
          }
        }
      } else {
        if (targetNode.isMain !== false) {
          targetNode.isMain = true;
        }
      }

      // If relation contains "type" (sourceType, typeOf, classType, etc.),
      // mark the target as a "type concept" so it can be light blue.
      if (relationText && relationText.toLowerCase().includes('type')) {
        targetNode.isTypeConcept = true;
      }
    }

    // ---------- Simple force-directed layout ----------

    function layoutNodesForce(nodes, edges, width, height) {
      if (!nodes.length) return;

      const centerX = width / 2;
      const centerY = height / 2;

      const n = nodes.length;
      const initRadius = Math.min(width, height) * 0.3;
      nodes.forEach((node, i) => {
        if (node.x == null || node.y == null) {
          const angle = (2 * Math.PI * i) / n;
          node.x = centerX + initRadius * Math.cos(angle);
          node.y = centerY + initRadius * Math.sin(angle);
        }
        node.vx = node.vx || 0;
        node.vy = node.vy || 0;
      });

      const nodeIndex = new Map(nodes.map((n, i) => [n.name, i]));

      const iterations = 80;
      const repulsion = 4000;
      const springLength = 120;
      const springK = 0.01;
      const centerPull = 0.005;
      const damping = 0.85;

      for (let iter = 0; iter < iterations; iter++) {
        nodes.forEach(node => {
          node.fx = 0;
          node.fy = 0;
        });

        // Node-node repulsion
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            let dist2 = dx * dx + dy * dy;
            if (dist2 === 0) {
              dx = (Math.random() - 0.5) * 0.1;
              dy = (Math.random() - 0.5) * 0.1;
              dist2 = dx * dx + dy * dy;
            }
            const dist = Math.sqrt(dist2);
            const force = repulsion / dist2;
            const fx = (force * dx) / dist;
            const fy = (force * dy) / dist;

            a.fx -= fx;
            a.fy -= fy;
            b.fx += fx;
            b.fy += fy;
          }
        }

        // Edge springs
        edges.forEach(e => {
          const a = nodes[nodeIndex.get(e.source)];
          const b = nodes[nodeIndex.get(e.target)];
          if (!a || !b) return;

          let dx = b.x - a.x;
          let dy = b.y - a.y;
          let dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
          const delta = dist - springLength;
          const force = springK * delta;
          const fx = (force * dx) / dist;
          const fy = (force * dy) / dist;

          a.fx += fx;
          a.fy += fy;
          b.fx -= fx;
          b.fy -= fy;
        });

        // Centering force
        nodes.forEach(node => {
          const dx = centerX - node.x;
          const dy = centerY - node.y;
          node.fx += centerPull * dx;
          node.fy += centerPull * dy;
        });

        // Integrate
        nodes.forEach(node => {
          node.vx = (node.vx + node.fx) * damping;
          node.vy = (node.vy + node.fy) * damping;
          node.x += node.vx;
          node.y += node.vy;
        });
      }
    }

    // ---------- Drawing with zoom/pan, colors, and definition badge ----------

    function drawGraphFromText(text) {
      const { nodes, edges } = parseGraph(text);
      currentNodes = nodes;
      currentEdges = edges;

      const w = canvas.width;
      const h = canvas.height;

      if (!nodes.length) {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, w, h);
        return;
      }

      layoutNodesForce(nodes, edges, w, h);
      drawGraph();
    }

    function drawGraph() {
      const nodes = currentNodes;
      const edges = currentEdges;
      const w = canvas.width;
      const h = canvas.height;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);

      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);

      if (!nodes.length) return;

      const nodeIndex = new Map(nodes.map((n, i) => [n.name, i]));

      // Draw edges
      ctx.strokeStyle = '#555';
      ctx.fillStyle = '#000';
      ctx.lineWidth = 1.5 / scale;
      ctx.font = `${12 / scale}px sans-serif`;

      for (const e of edges) {
        const s = nodes[nodeIndex.get(e.source)];
        const t = nodes[nodeIndex.get(e.target)];
        if (!s || !t) continue;

        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(t.x, t.y);
        ctx.stroke();

        const label = [e.relation, e.text].filter(Boolean).join(' | ');
        if (label) {
          const mx = (s.x + t.x) / 2;
          const my = (s.y + t.y) / 2;
          ctx.save();
          ctx.fillStyle = 'rgba(255,255,255,0.8)';
          const padding = 4 / scale;
          const textWidth = ctx.measureText(label).width;
          ctx.fillRect(
            mx - textWidth / 2 - padding,
            my - 10 / scale,
            textWidth + 2 * padding,
            16 / scale
          );
          ctx.fillStyle = '#333';
          ctx.fillText(label, mx - textWidth / 2, my + 2 / scale);
          ctx.restore();
        }
      }

      // Draw nodes with auto-sized boxes, colors, and a small badge if defined
      for (const node of nodes) {
        const label = node.name;

        ctx.font = `${12 / scale}px sans-serif`;
        const paddingX = 10 / scale;
        const paddingY = 6 / scale;

        const textWidth = ctx.measureText(label).width;
        const textHeight = 12 / scale;

        const boxWidth = textWidth + 2 * paddingX;
        const boxHeight = textHeight + 2 * paddingY;

        const x = node.x - boxWidth / 2;
        const y = node.y - boxHeight / 2;

        const isMain = node.isMain !== false;
        const isTypeConcept = node.isTypeConcept === true;
        const hasDefinition = node.hasDefinition === true;

        // Color logic:
        // - type concept: light blue
        // - other main concepts: dark blue
        // - non-main: light gray
        let fillColor;
        let textColor;

        if (isTypeConcept) {
          fillColor = '#8ec9ff';
          textColor = '#ffffff';
        } else if (isMain) {
          fillColor = '#0074D9';
          textColor = '#ffffff';
        } else {
          fillColor = '#e0e0e0';
          textColor = '#000000';
        }

        ctx.beginPath();
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = '#0074D9';
        ctx.lineWidth = 2 / scale;
        ctx.rect(x, y, boxWidth, boxHeight);
        ctx.fill();
        ctx.stroke();

        // Node label
        ctx.fillStyle = textColor;
        const textX = node.x - textWidth / 2;
        const textY = node.y + textHeight / 2 - 2 / scale;
        ctx.fillText(label, textX, textY);

        // Small definition badge (top-right corner) if hasDefinition
        if (hasDefinition) {
          const badgeSize = 8 / scale;
          const badgePadding = 3 / scale;
          const badgeX = x + boxWidth - badgeSize - badgePadding;
          const badgeY = y + badgePadding;

          ctx.beginPath();
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = '#333333';
          ctx.lineWidth = 1 / scale;
          ctx.arc(
            badgeX + badgeSize / 2,
            badgeY + badgeSize / 2,
            badgeSize / 2,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = '#333333';
          ctx.font = `${7 / scale}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('i', badgeX + badgeSize / 2, badgeY + badgeSize / 2);
          ctx.textAlign = 'start';
          ctx.textBaseline = 'alphabetic';
        }
      }
    }

    // ---------- Mouse wheel zoom ----------

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      const xBeforeZoom = (mouseX - offsetX) / scale;
      const yBeforeZoom = (mouseY - offsetY) / scale;

      const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
      const newScale = Math.min(maxScale, Math.max(minScale, scale * zoomFactor));

      scale = newScale;
      offsetX = mouseX - xBeforeZoom * scale;
      offsetY = mouseY - yBeforeZoom * scale;

      drawGraph();
    }, { passive: false });

    // ---------- Mouse drag pan ----------

    canvas.addEventListener('mousedown', (event) => {
      isPanning = true;
      canvas.classList.add('dragging');
      startPanX = event.clientX;
      startPanY = event.clientY;
      startOffsetX = offsetX;
      startOffsetY = offsetY;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isPanning) return;
      const dx = event.clientX - startPanX;
      const dy = event.clientY - startPanY;
      offsetX = startOffsetX + dx;
      offsetY = startOffsetY + dy;
      drawGraph();
    });

    window.addEventListener('mouseup', () => {
      isPanning = false;
      canvas.classList.remove('dragging');
    });

    // Initial sizing and draw
    resizeCanvas();
  </script>
</body>
</html>
